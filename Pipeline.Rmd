---
title: "Pipeline"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pipeline of the necessary steps in R and outside of R

## 1 Import data

First the traits table and the original tree have to be read into R in the right format to be able to use them. 

### The project root and the main tree
```{r define data root and import tree}
#load required package
library(ape)

#import and define data
project_root <- 'C:/Users/Esther/Documents/Master/Stage/'
tree_file <- paste(c(project_root, 'ALLMB.tre'), collapse = '')
tree <- read.tree(tree_file)
```

### Derived woodiness
```{r import derived woodiness data}
#import and define trait tables
woody_tsv_file <- paste(c(project_root, 'sdmdl-angiosperm-data/data/woody.tsv'), collapse = '')
woody_tsv <- read.table(woody_tsv_file, sep = '\t', header = TRUE)
```

### Mycorrhiza
```{r import mycorrhiza data}
#import and define trait table 
myco_tsv_file <- paste(c(project_root, 'sdmdl-angiosperm-data/data/myco_taxa.tsv'), collapse = '')
myco_tsv <- read.table(myco_tsv_file, sep = '\t', header = TRUE)
```

### Domestication 
```{r import domestication data}
#define trait table 
crops_tsv_file <- paste(c(project_root, 'sdmdl-angiosperm-data/data/crops.tsv'), collapse = '')
crops_tsv <- read.table(crops_tsv_file, sep = '\t', header = TRUE)
```

## 3 Recode dependent variables to binary form

The data of the dependent characters (the plant traits) have to be recoded. This is because a binary 
input is prefered for this analysis due to technical reasons, while all the data has 3 or 4 states at the
moment. 

### Derived woodiness
For Derived woodiness, there are 3 trait-states: derived woody (0), non-woody (1), ancestral woody (2). 
This will be turned into: derived woody (0) and non-woody (1). As this is the actual shift between 
non-woody and derived woodiness. So all the plants with ancestral woodiness (3) as trait, have to be 
eliminated from the analysis. 
```{r cut out state 2 tsv}
#define new sub-woody, which contains binary trait values (tsv)
woody_tsv_bi <- subset(woody_tsv, (woody_tsv$woody == 0 | woody_tsv$woody ==1))
```

How to do this in the nexus file (not necessary):
```{r cut out state 2 nex}
woody_nex_file <- paste(c(project_root, 'sdmdl-angiosperm-data/data/woody.nex'), collapse = '')
woody_nex <- read.nexus(woody_nex_file)

#define the taxathat should not be included (with value 2)
woody_tsv_2 <- subset(woody_tsv, (woody_tsv$woody == 2)) 
unwanted_tips_woody <- as.character(unlist(c(woody_tsv_2[1]))) 
unwanted_tips_woody <- sub(" ", "_", unwanted_tips_woody) #to make the names the same as in the swo tree. 

#make the subset in the original woody.nex file 
woody_bi_wrong <- drop.tip(woody_nex, unwanted_tips_woody)
#the previous command yielded a wrong dataset (as the name already tells us), it seems like the names still 
#do not match completely, we'll have to fix that. For now this is a different solution that also works: 
unwanted_numbers_woody <- as.numeric(row.names(woody_tsv_2))

#so define new sub-woody, which contains binary trait values (both nex and tsv)
woody_nex_bi <- drop.tip(woody_nex, unwanted_numbers_woody)

#the root edge is not present anymore in swo_bin, but that is okay. 
```

### Mycorrhiza
For mycorrhiza, there are 4 trait-states: EM, AM, both, neither. This will be turned into: AM (0) and 
the rest together (1). So in this case nothing will be eliminated from the analysis, just (1)(2)(3) have 
to be collapsed together. 
```{r collapse state 1,2,3}
#create new column
myco_tsv["myco_state_int"] <- NA

#add binary values to column based on names 
myco_tsv$myco_state_int[myco_tsv$myco_state == "arbuscular"] <- "0"
myco_tsv$myco_state_int[myco_tsv$myco_state == "ecto"] <- "1"
myco_tsv$myco_state_int[myco_tsv$myco_state == "both"] <- "1"
myco_tsv$myco_state_int[myco_tsv$myco_state == "neither"] <- "1"

#now myco_tsv_bi contains an added column with binary state values
```

### Domestication
For domestication, there are 3 trait-states: progenitor of domesticated (1), only domesticated (2) 
and semi-domesticated (3). 
This will be turned into: progenitor of domesticated and semi-domesticated together (1). This 
eliminates the species that just exist in their domesticated form, which have already been altered 
by human selection, so they can't tell us anything about pre-adaptations. 

#### Cut out state 2
```{r cut out state 2}
#cut out all the plants that have trait state 2 from the tsv file 
crops_tsv_1_3 <- subset(crops_tsv, (crops_tsv$domestication == 1 | crops_tsv$domestication == 3))

#combine states 1 and 3
crops_tsv_1_3$domestication_binary[crops_tsv_1_3$domestication == "1"] <- "1"
crops_tsv_1_3$domestication_binary[crops_tsv_1_3$domestication == "3"] <- "1"
```

#### Add state 0
The domestication database is not complete yet, some non-domesticated plants have to be added to 
serve as the 0 state. These plants will come from the main tree, based on their distance on the
pylogeny to the plants already included in the domestication traits table. 

 A. Import the right GIS data and make a GIS tree: 
```{r import GIS data}
#import GIS data 
GIS_file <- paste(c(project_root, 'niche_traits_merged.csv'), collapse = '')
GIS <- read.table(GIS_file, sep = ',', header = TRUE)

#change names of GIS data 
library(stringi)
GIS_names <- as.character(unlist(c(GIS[1])))
GIS_names <- gsub('  ', '. ', GIS_names)
GIS_names <- stri_replace_all_charclass(GIS_names, "\\p{WHITE_SPACE}", "_")

#there is a discrepancy with several names that should have a - instead of a _ in some places. 
#So we have to change those specific GIS names:
GIS_names[GIS_names == "Acaena_novae_zelandiae"] <- "Acaena_novae-zelandiae"
GIS_names[GIS_names == "Impatiens_noli_tangere"] <- "Impatiens_noli-tangere"  
GIS_names[GIS_names == "Myrrhidendron_donnell_smithii" ] <- "Myrrhidendron_donnell-smithii" 
GIS_names[GIS_names == "Silene_flos_cuculi"] <- "Silene_flos-cuculi"
GIS_names[GIS_names == "Pithecellobium_unguis_cati"] <- "Pithecellobium_unguis-cati"
GIS_names[GIS_names == "Hyacinthoides_non_scripta" ] <- "Hyacinthoides_non-scripta" 
GIS_names[GIS_names == "Alisma_plantago_aquatica"] <- "Alisma_plantago-aquatica" 
GIS_names[GIS_names == "Apera_spica_venti"] <- "Apera_spica-venti"
GIS_names[GIS_names == "Arctostaphylos_uva_ursi"] <- "Arctostaphylos_uva-ursi"
GIS_names[GIS_names == "Blitum_bonus_henricus"] <- "Blitum_bonus-henricus"
GIS_names[GIS_names == "Begonia_meyeri_johannis"] <- "Begonia_meyeri-johannis"
GIS$allmb_name <- GIS_names

#make the selection
tips_to_drop_GIS <- setdiff(tree$tip.label, GIS_names)
GIS_tree <- drop.tip(tree, tips_to_drop_GIS)

#are there still names that do not match?
nomatch_GIS_tree <- setdiff(GIS_names, GIS_tree$tip.label)
print(nomatch_GIS_tree)

#change the name of this subspecies to Zea_mays, otherwise there will be miscommunication during the model selction
GIS_names[GIS_names == "Zea_mays_subsp._parviglumis"] <- "Zea_mays"
GIS$allmb_name <- GIS_names

#now change the name in the crops_tsv_1_3 file as well, so that the selection later on goes well
crops_1_3$allmb_name[crops_1_3$allmb_name == "Zea_mays_subsp._parviglumis"] <- "Zea_mays"
```

#### B. Tidy data
The tree and the traits-tables have to match, but there are plants in the phylogeny (tree) that are 
not in the traits table -> cut these out of the tree. It could be true that the taxa names don't 
match between the tree file and the trait-table, in that case not the same amount of taxa will still
be in the tree as there are in the trait table. If that is the case, this has to be fixed!
```{r trim tree}
#define the temporary tree for domestication out of the GIS tree
keep_tips_crops_1_3 <- as.character(unlist(c(crops_1_3[1]))) 
tips_to_drop_crops <- setdiff(GIS_tree$tip.label, keep_tips_crops_1_3)
tree_crops_tsv <- drop.tip(GIS_tree, tips_to_drop_crops)

#make a vector of the taxa names that are still in the tree
crops_names <- as.character(unlist(c(tree_crops_temp$tip.label)))

#there are only 34 taxa in this tree, as there is not enough information for all the taxa that are in the tsv file
```

#### C. Now do the distance matrix calculations
```{r distance matrix calculations}
#make a patristic distance matrix, this shows the phylogenetic distances between all the species in the tree
distances <- cophenetic.phylo(GIS_tree)

#print the 34 taxa names that all have state 1
print(crops_names)

#search for a non-domesticated species (state 0) inside the matrix for every printed species (state 1) name above, 
#sort the results based on the phylogenetic distance, and print the first 20 results
head(sort(distances[,colnames(distances) == crops_names[26]]), n=30) 

#define a new vector with the 34 new taxa names 
allmb_name <- c("Euphorbia_usambarica", "Calycophysum_pedunculatum", "Ibervillea_sonorae", "Psiguria_triphylla", "Gurania_eriantha", "Doyerea_emetocathartica", "Ficus_pandurata", "Fissicalyx_fendleri", "Dendrosida_sharpiana_subsp._pubescens", "Ipomoea_arborescens", "Heliconia_psittacorum", "Tradescantia_zebrina", "Amischotolype_hispida", "Scleria_gaertneri", "Festuca_arundinacea_subsp._orientalis", "Pogonarthria_squarrosa", "Digitaria_ischaemum", "Digitaria_violascens", "Elymus_repen", "Aegilops_cylindrica", "Aegilops_crassa", "Elymus_elongatus", "Poa_colensoi", "Molineria_capitulata", "Polygonatum_verticillatum", "Epipactis_helleborine", "Evodianthus_funifer", "Schoenoplectus_pungens_var._badius", "Helictotrichon_desertorum_subsp._basalticum", "Eleocharis_acutangula_subsp._breviseta", "Raddiella_esenbeckii", "Dienia_ophrydis", "Arum_maculatum", "Calla_palustris")

#create a new dataframe for the state 0 taxa, and add columns that correspond with the ones in crops_tsv_1_3
crops_state0 <- data.frame(allmb_name)
crops_state0$gbif_species_key <- "NA"
crops_state0$domestication <- "0"
crops_state0$progenitor_of <- "NA"
crops_state0$domestication_binary <- "0"

#combine the two dataframes into one new complete dataframe 
crops_bi <- rbind(crops_1_3, crops_state0)  
```

## 4 Tidy data

### Trim the tree 
The tree and the traits-tables have to match, but there are plants in the phylogeny (tree) that are 
not in the traits table -> cut these out of the tree. It could be true that the taxa names don't 
match between the tree file and the trait-table, in that case not the same amount of taxa will still
be in the tree as there are in the trait table. If that is the case, this has to be fixed!
This step is not necessary for the rest of the analysis, but it is a handy checkpoint to make sure 
all the names match. 

#### Derived woodiness
```{r trim derived woodiness tree}
#load required package
library(stringi)

#define the final tree for woodiness
keep_tips_woody_tsv_bi <- as.character(unlist(c(woody_tsv_bi[1]))) 
keep_tips_woody_tsv_bi <- stri_replace_all_charclass(keep_tips_woody_tsv_bi, "\\p{WHITE_SPACE}", "_")

tips_to_drop_woody <- setdiff(tree$tip.label, keep_tips_woody_tsv_bi)
woody_tree <- drop.tip(tree, tips_to_drop_woody)

#it works! the woody_tree now also contains only 749 tips/taxa.  
```

#### Mycorrhiza 
```{r trim mycorrhiza tree}
#load required package
library(stringi)

#define the final tree for myc
keep_tips_myco_tsv_bi <- as.character(unlist(c(myco_tsv[1]))) 
keep_tips_myco_tsv_bi <- stri_replace_all_charclass(keep_tips_myco_tsv_bi, "\\p{WHITE_SPACE}", "_")

tips_to_drop_myco <- setdiff(tree$tip.label, keep_tips_myco_tsv_bi)
myco_tree <- drop.tip(tree, tips_to_drop_myco)
```

#### Domestication 
```{r trim domestication tree}
#load required package
library(stringi)

#define the final tree for dom
keep_tips_crops_tsv_bi <- as.character(unlist(c(crops_tsv_bi[1]))) 
keep_tips_crops_tsv_bi <- stri_replace_all_charclass(keep_tips_crops_tsv_bi, "\\p{WHITE_SPACE}", "_")

tips_to_drop_crops <- setdiff(tree$tip.label, keep_tips_crops_tsv_bi)
crops_tree <- drop.tip(tree, tips_to_drop_crops)
```

### Make sure the names match 

#### Example for checking the names if they don't match: Secondary woodiness
```{r match names derived woodiness}
#make vector of the names that do not match
keep_tips_woody_tsv_bi
nomatch_names_woody <- setdiff(keep_tips_woody_tsv_bi, woody_tree$tip.label)

#print the names
print(nomatch_names_woody) 

#it turns out that not all the white spaces were substituted by _ with the sub(" ", "_") command
#so used a different command: 
keep_tips_woody_tsv_bi <- stri_replace_all_charclass(keep_tips_woody_tsv_bi, "\\p{WHITE_SPACE}", "_")
```

## 5 Combine the data

The trait states, the selected subset of taxa names, and the GIS information all have to be combined into one file. 
It makes sense if the number of plants in the final GIS table is not the same as in the tsv files or as in the 
subtrees, this is because there are either not enough occurrences of some plants, or those occurrences were not 
valid, etc. 

### Import data
Import the data and make sure the taxa names are the same in this table as in the tsv file and in the tree file,
so with _ instead of spaces 
```{r import GIS data}
#import GIS data
GIS_file <- paste(c(project_root, 'niche_traits_merged.csv'), collapse = '')
GIS <- read.table(GIS_file, sep = ',', header = TRUE)

#change names of GIS data 
GIS_names <- as.character(unlist(c(GIS[1])))
GIS_names <- gsub('  ', '. ', GIS_names)
GIS_names <- stri_replace_all_charclass(GIS_names, "\\p{WHITE_SPACE}", "_")

#there is a discrepancy with several names that should have a - instead of a _ in some places. 
#So we have to change those specific GIS names:
GIS_names[GIS_names == "Acaena_novae_zelandiae"] <- "Acaena_novae-zelandiae"
GIS_names[GIS_names == "Impatiens_noli_tangere"] <- "Impatiens_noli-tangere"  
GIS_names[GIS_names == "Myrrhidendron_donnell_smithii" ] <- "Myrrhidendron_donnell-smithii" 
GIS_names[GIS_names == "Silene_flos_cuculi"] <- "Silene_flos-cuculi"
GIS_names[GIS_names == "Pithecellobium_unguis_cati"] <- "Pithecellobium_unguis-cati"
GIS_names[GIS_names == "Hyacinthoides_non_scripta" ] <- "Hyacinthoides_non-scripta" 
GIS_names[GIS_names == "Alisma_plantago_aquatica"] <- "Alisma_plantago-aquatica" 
GIS_names[GIS_names == "Apera_spica_venti"] <- "Apera_spica-venti"
GIS_names[GIS_names == "Arctostaphylos_uva_ursi"] <- "Arctostaphylos_uva-ursi"
GIS_names[GIS_names == "Blitum_bonus_henricus"] <- "Blitum_bonus-henricus"
GIS_names[GIS_names == "Begonia_meyeri_johannis"] <- "Begonia_meyeri-johannis"
GIS$allmb_name <- GIS_names
```

### Tidy data
Make the right selection of taxa out of the GIS variables table and of the tree. 

#### Derived woodiness
```{r trim GIS table derived woodiness}
#select the taxa that should be kept in the GIS file
keep_GIS_woody <- as.character(unlist(c(woody_tsv_bi[1])))
#define the final GIS file for woodiness
GIS_woody <- GIS[GIS$allmb_name %in% keep_GIS_woody,]

#select the names that have to be kept in the tree
keep_tips_woody <- as.character(unlist(c(GIS_woody[1]))) 
#define the final tree for mycorrhiza
tips_to_drop_woody <- setdiff(tree$tip.label, keep_tips_woody)
tree_woody <- drop.tip(tree, tips_to_drop_woody)
```

#### Mycorrhiza
```{r trim GIS table mycorrhiza}
#select the taxa that should be kept in the GIS file
keep_GIS_myco <- as.character(unlist(c(myco_tsv[1]))) 
#define the final GIS file for mycorrhiza
GIS_myco <- GIS[GIS$allmb_name %in% keep_GIS_myco,]

#select the names that have to be kept in the tree
keep_tips_myco <- as.character(unlist(c(GIS_myco[1]))) 
#define the final tree for mycorrhiza
tips_to_drop_myco <- setdiff(tree$tip.label, keep_tips_myco)
tree_myco <- drop.tip(tree, tips_to_drop_myco)
```

#### Crops
```{r trim GIS table domestication}
#select the taxa that should be kept in the GIS file
keep_GIS_crops <- as.character(unlist(c(crops_bi[1]))) 
#define the final GIS file for domestication
GIS_crops <- GIS[GIS$allmb_name %in% keep_GIS_crops,]

#select the names that have to be kept in the tree
keep_tips_crops <- as.character(unlist(c(GIS_crops[1]))) 
#define the final tree for domestication
tips_to_drop_crops <- setdiff(tree$tip.label, keep_tips_crops)
tree_crops <- drop.tip(tree, tips_to_drop_crops)
```

### Add the binary trait state to the GIS table

#### Derived woodiness
```{r add binary state to GIS table derived woodiness}
#make new tables for both woodiness states separately 
GIS_woody_0 <- woody_tsv_bi[woody_tsv_bi$woody == "0",]
GIS_woody_1 <- woody_tsv_bi[woody_tsv_bi$woody == "1",]

#add a column to GIS_woody that contains the binary trait values
GIS_woody$woody[GIS_woody$allmb_name %in% GIS_woody_0$allmb_name] <- "0"  
GIS_woody$woody[GIS_woody$allmb_name %in% GIS_woody_1$allmb_name] <- "1"

#change order of the columns for esthetics
GIS_woody <- GIS_woody[,c(1,43, 2:42)]
```

#### Mycorrhiza
```{r add binary state to GIS table mycorrhiza}
#make new tables for both mycorrhiza states separately 
GIS_myco_0 <- myco_tsv[myco_tsv$myco_state_int == "0",]
GIS_myco_1 <- myco_tsv[myco_tsv$myco_state_int == "1",]

#add a column to GIS_myco that contains the binary trait values
GIS_myco$mycorrhiza[GIS_myco$allmb_name %in% GIS_myco_0$allmb_name] <- "0"
GIS_myco$mycorrhiza[GIS_myco$allmb_name %in% GIS_myco_1$allmb_name] <- "1"

#change order of the columns for esthetics
GIS_myco <- GIS_myco[,c(1,43, 2:42)]
```

#### Domestication
```{r add binary state to GIS table domestication}
#make new tables for both domestication states separately 
GIS_crops_1 <- crops_tsv_1_3[crops_tsv_1_3$allmb_name %in% GIS$allmb_name,]
GIS_crops_0 <- crops_df_state0[crops_df_state0$allmb_name %in% GIS$allmb_name,]

#add column to GIS_crops and add domestication state
GIS_crops$domestication[GIS_crops$allmb_name %in% GIS_crops_1$allmb_name] <- "1"
GIS_crops$domestication[GIS_crops$allmb_name %in% GIS_crops_0$allmb_name] <- "0"

#change order of the columns for esthetics
GIS_crops <- GIS_crops[,c(1,43, 2:42)]
```

## 6 Correct for colinearity in the predictor variables

There will probably be some colinearity in the GIS-data. This could lead to instability and bias in the model, 
so a correction will have to be done. This can be done using the variance inflation factor (of the usdm package)
or a correlation matrix. See the VIF_analysis files for details of the decision making process.

### VIF-analysis purely based on highest VIF value: Woodiness
```{r}
vif(GIS_woody[,c(3:5, 14, 15, 17, 18, 20, 22:24, 38, 39, 42, 43)])

#excluded: BIO7 (31), BIO11(35), continentality (9), BIO10 (34), BIO4 (28), BIO1 (25), growingDegDays0 (11), maxTempColdest (13), PETColdestQuarter (16), 
#BIO16 (40), annualPET (6), BIO12 (36), BIO17 (41), thermicityIndex (21), BIO5 (29), BIO6 (30), growingDegDays5 (12), climaticMoistureIndex (8), 
#PETWarmestQuarter (19), BIO8 (32), BIO3 (27), BIO9 (33), BIO13 (37), aridityIndexThornthwaite (7), embergerQ (10), BIO2 (26), 

#result is 3 left of the variables we wanted. 
```

### VIF-analysis purely based on highest VIF value: Mycorrhiza
```{r}
vif(GIS_myco[,c(3:5, 7, 14, 20, 22:24, 26, 28, 39, 42, 43)])

#excluded: BIO7 (31), BIO11(35), continentality (9), BIO10 (34), maxTempColdest (13), BIO6 (30), BIO1 (25), annualPET (6), growingDegDays0 (11), 
#PETColdestQuarter (16), thermicityIndex (21), BIO13 (37), BIO17 (41), BIO5 (29), BIO9 (33), BIO12 (36), BIO3 (27), growingDegDays5 (12), BIO8 (32), 
#PETWarmestQuarter (19), BIO16 (40), monthCountByTemp10 (15), embergerQ (10), PETDriestQuarter (17), climaticMoistureIndex (8), BIO14 (38), PETseasonality (18)

#result is 5 left of the variables we wanted
```

### VIF-analysis purely based on highest VIF value: Domestication
```{r}
vif(GIS_crops[,c(3:5, 14, 17, 18, 22:24, 26, 38, 39)])

#excluded: BIO7 (31), BIO11(35), continentality (9),BIO4 (28), BIO1 (25), maxTempColdest (13), growingDegDays0 (11), BIO10 (34), annualPET (6), BIO17 (41),
#PETColdestQuarter (16), BIO12 (36), thermicityIndex (21), growingDegDays5 (12), BIO6 (30), BIO16 (40), BIO5 (29), PETWettestQuarter (20), climaticMoistureIndex (8), 
#BIO9 (33), embergerQ (10), BIO3 (27), #aridityIndexThornthwaite (7), BIO8 (32), BIO18 (42), PETWarmestQuarter (19), BIO19 (43), BIO13 (37), monthCountByTemp10 (15)

#result is 4 left of the variables we wanted. 
```

### VIF-analysis: Derived woodiness
```{r VIF analysis derived woodiness}
#load required package
library(usdm)

#fill in the arguments of the function and execute it 
vif(GIS_woody)

#choose variables to delete that have a higher VIF value than 10, but make sure it makes sense in terms of biology, resulting in:
# 1. Without ClimaticMoistureIndex: 
vif(GIS_woody[,c(3:5, 14, 15, 17, 18, 20, 22:24, 38, 39, 42, 43)])

# 2. With ClimaticMoistureIndex:
vif(GIS_woody[,c(3:5, 8, 14, 17, 18, 20, 22:24, 39, 43)])

# 3. With BIO6, without ClimaticMoistureIndex:
vif(GIS_woody[,c(3:5, 14, 15, 17, 20, 22:24, 30, 38, 39, 42, 43)]) 

# 4. With BIO6, with ClimaticMoistureIndex:
vif(GIS_woody[,c(3:5, 8, 14, 17, 20, 22:24, 30, 39, 43)]) 
```

### VIF-analysis: Mycorrhiza
```{r VIF analysis mycorrhiza}
#load required package
library(usdm)

#fill in the arguments of the function and execute it 
vif(GIS_myco)

#choose the variables to delete that have a higher VIF value than 10, but make sure it makes sense in terms of biology, results in:
# 1. Without embergerQ
vif(GIS_myco[,c(3:5, 7, 14, 20, 22:24, 26, 28, 39, 42, 43)])

# 2. With embergerQ
vif(GIS_myco[,c(3:5, 7, 10, 14, 20, 22:24, 26, 28, 39, 42)]) 
```

### VIF-analysis: Domestication 
```{r VIF analysis domestication}
#load required package
library(usdm)

#fill in the arguments of the function and execute it 
vif(GIS_crops)

#choose a variable to delete that has a higher VIF value than 10, but make sure it makes sense in terms of biology 
```

## 7 Model selection: Define formula and select model 

The linear model will have to be made, with the trait-presence-column as the dependent variable, and the 
GIS data frames as the predictor variables. The function phylostep of the phylolm package will be used. 

### Derived woodiness
```{r model selection derived woodiness}
#load required package
library(phylolm)

#define formula components and run function
phylostep(formula = , starting.formula = woody ~ 1, data = GIS_woody, phy = tree_woody, model = "BM", direction = "forward", trace = 2)
```

### Mycorrhiza
```{r model selection mycorrhiza}
#load required package
library(phylolm)

#define formula components and run function
phylostep(formula = , starting.formula = mycorrhiza ~ 1, data = GIS_myco, phy = tree_myco, model = "BM", direction = "forward", trace = 2)
```

### Domestication
```{r model selection domestication}
#load required package
library(phylolm)

#define formula components and run function
phylostep(formula = , starting.formula = domestication ~ 1, data = GIS_crops, phy = tree_crops, model = "BM", direction = "forward", trace = 2)
```

## 8 Phylogenetic generalized linear modelling analysis

After this, the phylogenetic generalized linear modeling analysis will be done, which optimizes the model. 
There is a function in the phylolm package that allows us to do this: phyloglm. 

### Derived woodiness
```{r phylogenetic generalized linear modelling derived woodiness}
#fill in the arguments for the phyloglm function and execute it
phyloglm(formula = , data = GIS_woody, phy = tree_woody, method = , btol = , log.alpha.bound = , start.beta = , start.alpha = , boot = , full.matrix = )
```

### Mycorrhiza
```{r phylogenetic generalized linear modelling mycorrhiza}
#fill in the arguments for the phyloglm function and execute it
phyloglm(formula = , data = GIS_myco, phy = tree_myco, method = , btol = , log.alpha.bound = , start.beta = , start.alpha = , boot = , full.matrix = )
```

### Domestication
```{r phylogenetic generalized linear modelling domestication}
#fill in the arguments for the phyloglm function and execute it
phyloglm(formula = , data = GIS_crops, phy = tree_crops, method = , btol = , log.alpha.bound = , start.beta = , start.alpha = , boot = , full.matrix = )
```

## 9 Biological interpretation

In the end, the final models and the predictor variables that are included will have to be interpreted biologically. 
With this knowledge, the thesis can be completed and the research questions can be answered. 

